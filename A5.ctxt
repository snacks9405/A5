#BlueJ class context
comment0.target=A5
comment1.params=fileName
comment1.target=void\ loadWords(java.lang.String)
comment1.text=\r\n\ \ Given\ the\ name\ of\ a\ text\ file,\ loads\ the\ words\ contained\r\n\ \ in\ that\ file\ into\ the\ dict\ data\ structure.\ You\ should\ assume\r\n\ \ that\ if\ the\ file\ exists,\ it\ contains\ only\ words\ made\ up\ of\r\n\ \ upper-\ and/or\ lowercase\ letters\ separated\ by\ the\ default\ delimiter\r\n\ \ characters\ (e.g.,\ blank\ space,\ newline\ character,\ etc.).\ In\ the\ end,\r\n\ \ dict\ may\ only\ contain\ words\ in\ all\ lowercase\ letters\ with\ no\ duplicates.\ \r\n\ \ If\ the\ file\ does\ not\ exist,\ a\ clear\ message\ must\ be\ printed\ on\ the\ \r\n\ \ terminal\ before\ terminating\ the\ program.\ \r\n\ \ \r\n\ \ Does\ NOT\ send\ any\ output\ to\ the\ terminal\ if\ the\ input\ file\ exists.\r\n\ \ \ \r\n\ \ @param\ fileName\ \ \ name\ of\ the\ text\ file\ of\ words\r\n
comment2.params=word
comment2.target=void\ findNeighbors(java.lang.String)
comment2.text=\r\n\ \ Given\ a\ word\ in\ dict,\ insert\ an\ entry\ into\ the\ neighbors\ data\ structure\r\n\ \ with\ this\ word\ as\ the\ key\ and\ the\ non-empty,\ alphabetized\ list\ of\ all\ of\ the\ word's\ \r\n\ \ neighbors\ as\ the\ value,\ where\ a\ neighbor\ of\ a\ word\ w\ is\ any\ other\ word\ in\ dict\ \r\n\ \ that\ is\ obtained\ by\ replacing\ exactly\ (any)\ one\ letter\ in\ w\ by\ another\ letter.\r\n\ \ Does\ not\ modify\ neighbors\ if\ the\ given\ word\ has\ no\ neighbors\ in\ dict.\r\n\ \ \r\n\ \ Does\ NOT\ send\ any\ output\ to\ the\ terminal.\r\n\ \ \r\n\ \ @param\ word\ \ \ the\ word\ whose\ neighbors\ you\ must\ determine\ and\ store\ in\ neighbors\r\n
comment3.params=
comment3.target=void\ findAllNeighbors()
comment3.text=\r\n\ \ Populates\ the\ neighbors\ data\ structure\ with\ an\ entry\ for\ each\ one\ of\ the\ words\ in\ \r\n\ \ dict\ whose\ neighbors\ list\ is\ not\ empty.\r\n\ \ \r\n\ \ Does\ NOT\ send\ any\ output\ to\ the\ terminal.\r\n
comment4.params=
comment4.target=void\ printAllNeighbors()
comment4.text=\r\n\ \ Sends\ the\ contents\ of\ the\ neighbors\ data\ structure\ to\ the\ terminal.\r\n\ \ The\ required\ format\ of\ this\ output\ is\ described\ in\ the\ handout\ for\ this\r\n\ \ assignment.\r\n
comment5.params=
comment5.target=void\ testMe()
comment6.params=start\ finish
comment6.target=java.util.ArrayList\ findSequence(java.lang.String,\ java.lang.String)
comment6.text=\r\n\ \ Returns\ a\ sequence\ connecting\ the\ two\ given\ words,\ where\ a\ sequence\ is\ a\ list\r\n\ \ of\ words\ with\ each\ word\ (except\ the\ first\ one)\ being\ a\ neighbor\ of\ the\ preceding\r\n\ \ word;\ or\ returns\ null\ if\ no\ such\ sequence\ exists\ (based\ on\ the\ dictionary\ used).\r\n\ \ \r\n\ \ Does\ NOT\ send\ any\ output\ to\ the\ terminal.\r\n\ \ \r\n\ \ @param\ \ start\ \ \ the\ word\ that\ must\ appear\ first\ in\ the\ sequence\r\n\ \ @param\ \ finish\ \ the\ word\ that\ must\ appear\ last\ in\ the\ sequence\r\n\ \ \r\n\ \ For\ full\ credit,\ your\ method\ must\ implement\ the\ following\ algorithm\:\r\n\ \ \ +\ you\ must\ use\ a\ basic\ (i.e.,\ FIFO)\ queue,\ called\ q,\ containing\ ArrayList<String>\r\n\ \ \ \ \ instances;\ each\ array\ list\ will\ be\ a\ partial\ sequence\ starting\ with\ the\ start\ \r\n\ \ \ \ \ word\r\n\ \ \ +\ initialize\ q\ to\ contain\ a\ single\ ArrayList\ with\ start\ as\ its\ only\ element\ \r\n\ \ \ +\ you\ will\ implement\ a\ loop\ that\ terminates\ when\ the\ first\ sequence\ ending\ in\ \r\n\ \ \ \ \ the\ finish\ word\ is\ about\ to\ be\ added\ to\ q\ or\ when\ q\ is\ empty\ (in\ the\ latter\ case,\r\n\ \ \ \ \ the\ method\ must\ return\ null).\r\n\ \ \ +\ during\ each\ iteration,\ you\ must\:\r\n\ \ \ \ \ \ \ +\ dequeue\ the\ first\ element\ (i.e.,\ ArrayList)\ of\ q;\ call\ this\ element\ 'current'\r\n\ \ \ \ \ \ \ +\ find\ the\ list\ of\ neighbors\ of\ current's\ last\ element\r\n\ \ \ \ \ \ \ \ \ \ \ +\ if\ one\ of\ them\ is\ the\ finish\ word,\ return\ current\ with\ this\ word\ added\ at\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ the\ end\r\n\ \ \ \ \ \ \ \ \ \ \ +\ if\ this\ list\ is\ empty,\ end\ the\ iteration\ since\ there\ is\ no\ way\ to\ \r\n\ \ \ \ \ \ \ \ \ \ \ \ \ extend\ the\ current\ partial\ sequence\r\n\ \ \ \ \ \ \ \ \ \ \ +\ otherwise,\ for\ each\ neighbor\ n\ in\ the\ list\:\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ +\ make\ a\ copy\ of\ current\ and\ add\ n\ at\ the\ end\ of\ this\ copy\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ +\ enqueue\ the\ resulting\ ArrayList\ into\ q\r\n\ \ \ \r\n\ \ This\ method\ may\ ONLY\ use\ the\ Queue\ (not\ Deque,\ etc.)\ methods\ that\ do\ NOT\ throw\r\n\ \ any\ exceptions.\r\n\ \ \r\n\ \ Sample\ outputs\ for\ this\ method\ are\ provided\ in\ the\ handout\ for\ this\ assignment.\r\n
comment7.params=args
comment7.target=void\ main(java.lang.String[])
comment7.text=\r\n\ \ Driver\ code,\ which\ you\ may\ NOT\ modify.\r\n\ \ \r\n\ \ Usage\:\r\n\ \ \ \ \ \ \ \ \ \ \ java\ A5\ <file\ name>\ neighbors\r\n\ \ \ \ \ \ \ \ or\r\n\ \ \ \ \ \ \ \ \ \ \ java\ A5\ <file\ name>\ \r\n
numComments=8
